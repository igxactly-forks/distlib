<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>distlib: libdist - C++ utilities for Distributed Computing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">distlib
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
   <div id="projectbrief">Library of C++ utilities for Distributed Systems.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">libdist - C++ utilities for Distributed Computing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><table class="doxtable">
<tr>
<th align="left">distlib</th><th align="right">0.8.0  </th></tr>
<tr>
<td align="left">Author </td><td align="right"><a href="https://www.linkedin.com/in/mmassenzio">M. Massenzio</a> </td></tr>
<tr>
<td align="left">Updated </td><td align="right">2017-09-17 </td></tr>
</table>
<h1>Install &amp; Build</h1>
<h2>Conan packages</h2>
<p>To build the project, you need to first donwload/build the necessary binary dependencies, as listed in <code>conanfile.text</code>.</p>
<p>This is done as follows:</p>
<div class="fragment"><div class="line">$ sudo -H pip install -U conan</div><div class="line">$ mkdir .conan &amp;&amp; cd .conan</div><div class="line">$ conan install .. -s compiler=clang -s compiler.version=3.6 \</div><div class="line">    -s compiler.libcxx=libstdc++11 --build=missing</div></div><!-- fragment --><p><b>note</b> &gt;I've found Conan not to work terribly well inside virtualenvs - but if you can make it work there, that'd be the preferred way.</p>
<p>After the dependencies are built, you can see information about them using <code>conan info ..</code> (the commands above assume that <code>clang</code> is configured on the <code>PATH</code> and that you have version 3.6 installed).</p>
<p>See also <code>CMakeLists.txt</code> for the changes necessary to add Conan's builds to the targets.</p>
<p>We use the following packages in this project:</p>
<ul>
<li><a href="http://www.conan.io/source/cryptopp/5.6.3/riebl/testing">cryptopp 5.6.3</a></li>
<li><a href="http://www.conan.io/source/glog/0.3.4/dwerner/testing">glog 0.3.4</a></li>
<li><a href="http://www.conan.io/source/gtest/1.8.0/lasote/stable">gtest 1.8.0</a></li>
<li><a href="http://www.conan.io/source/libzmq/4.1.5/memsharded/stable">ZMQ 4.1.5</a></li>
<li><a href="http://www.conan.io/source/OpenSSL/1.0.2j/lasote/stable">OpenSSL 1.0.2j</a></li>
<li><a href="http://www.conan.io/source/Protobuf/2.6.1/memsharded/testing">Protobuf 2.6.1</a></li>
</ul>
<p>See <a href="http://conan.io">conan.io</a> for more information.</p>
<h3>Google Protocol Buffers</h3>
<p>The <a href="#swim_gossip_and_consensus_algorithm">SWIM gossip protocol implementation</a> makes use of Protobuf as the serialization protocol to exchange status messages between servers.</p>
<p>The code in this project has been tested using <a href="https://github.com/google/protobuf/releases/tag/v2.6.1">Protocol Buffers 2.6.1</a>, installed via the <a href="https://conan.io/source/Protobuf/2.6.1/memsharded/testing">Conan's memshared package</a>.</p>
<h2>Build &amp; testing</h2>
<p>To build the project, it is the usual <code>cmake</code> routine: </p><pre class="fragment">$ mkdir build &amp;&amp; cd build
$ cmake -DINSTALL_DIR=${INSTALL_DIR} \
        -DCMAKE_CXX_COMPILER=/usr/local/bin/clang++ \
        -DCOMMON_UTILS_DIR=/path/to/commons.cmake ..
$ cmake --build .
</pre><p>Finally, to run the tests: </p><pre class="fragment">$ ./tests/bin/distlib_test
</pre><p>or to simply run a subset of the tests with full debug logging: </p><pre class="fragment">$ GLOG_v=2 ./tests/bin/distlib_test --gtest_filter=SwimServer*
</pre><p>See also the other binaries in the <code>build/bin</code> folder for more options.</p>
<h1>Projects</h1>
<h2>API Documentations</h2>
<p>All the classes are documented using <a href="https://massenz.github.io/distlib/">Doxygen</a>.</p>
<h2>Consistent Hashing</h2>
<p>See the <a href="http://www.cs.princeton.edu/courses/archive/fall07/cos518/papers/chash.pdf">Consistent Hash paper</a> for more details.</p>
<p>The code implementation here is a simple example of how to implement a set of <code>buckets</code> so that nodes in a distributed systems could use the consistent hashing algorithm to allow nodes to join/leave the ring, without causing massive reshuffles of the partitioned data.</p>
<p>A <code><a class="el" href="classView.html">View</a></code> is then a collection of <code>Buckets</code>, which define how the unity circle is divided, via the <code>consistent_hashing()</code> method and every partitioned item is allocated to a (named) <code><a class="el" href="classBucket.html">Bucket</a></code>: see the <a href="tests/test_view.cpp">tests</a> for an example of adding/removing buckets and how this only causes a fraction of the items to be re-shuffled.</p>
<h2>Merkle Trees</h2>
<p>See <a href="https://codetrips.com/2016/06/19/implementing-a-merkle-tree-in-c/">this post</a> for more details.</p>
<h2>SWIM Gossip and Consensus algorithm</h2>
<h3>PING demo server</h3>
<p>This is based on <a href="http://api.zeromq.org/2-1:zmq-cpp">ZeroMQ C++ bindings</a> and is an example implementation using the <code>SwimServer</code> class.</p>
<p>The same binary can act both as one continuously listening on a given <code>port</code> or as a client sending a one-off status update to a <code>destination</code> TCP socket.</p>
<p>See the <a href="#install_and_build">Install &amp; Build</a> section above to build the <code>swim_server_demo</code> target, then start the listening server: </p><div class="fragment"><div class="line">./build/bin/swim_server_demo receive --port=3003</div></div><!-- fragment --><p>and it will be listening for incoming <a href="proto/swim.proto"><code>SwimStatus</code></a> messages on port <code>3003</code>; a client can then send a message updates for five seconds using:</p>
<div class="fragment"><div class="line">./build/bin/swim_server_demo send --host=tcp://localhost:3003 --duration=5</div></div><!-- fragment --><p> (obviously, change the hostname if you are running the two on separate machines/VMs/containers).</p>
<p>Use the <code>--help</code> option to see the full list of available options.</p>
<h3>Full-fledged SWIM Detector implementation</h3>
<p>A reference implementatio of a failure detector based on the SWIM Gossip protocol is provided in the <a href="src/examples/gossip_example.cpp"><code>gossip_example</code></a> demo.</p>
<p>Again, use: </p><pre class="fragment">$ ./build/bin/gossip_detector_example -h
</pre><p>to see all the available options; <a href="bin/run_example"><code>bin/run_example</code></a> will start three detectors in background and will connect each other to demonstrate how they can detect failures (you can keep killing and restarting them, and see how the reports change).</p>
<p>Below is a short description of how this works, full details of the protocol in the <a href="#references">references</a>.</p>
<h3>Server states</h3>
<div class="image">
<img src="distlib-states.png" alt="distlib-states.png"/>
<div class="caption">
States Diagram</div></div>
<p> After startup, a <code>SwimServer</code> can <code>ping()</code> one or more of the servers that have been named as <code>seeds</code> (perhaps, as a CLI <code>--seeds</code> arguments, or named in a config file) and will be inserted into the list of <code>Alive</code> peers; afterwards, other peers will learn of this server's <code>Alive</code> state via the Gossip protocol, as this is <code>reported</code> to them as being <code>Alive</code>.</p>
<p>Subsequently, at regular intervals (but randomly, from the list of <code>Alive</code> servers) successful <code>ping()</code> requests will keep this server in the pool of peers' lists of <code>Alive</code> peers.</p>
<p>If one of the pings fails, or the server is reported by one of the peers to be <code>Suspected</code>, it will be placed in the appropriate list and, after a (configurable) timeout lapses, it will be considered as <code>Terminated</code> and removed from the list.</p>
<p>Once in the <code>Suspected</code> list, a server is never pinged again from the detector; however, it may come back <code>Alive</code> under one of these conditions (and <b>before</b> the timeout expires):</p>
<ul>
<li><em>indirectly</em>, when one of the other peers reports it to be <code>Alive</code>;</li>
<li><em>directly</em>, if the server receives a <code>ping()</code> request from the <code>Suspected</code> server which arrives <b>after</b> a similar <code>ping()</code> request from this server had failed (and caused the other server to be <code>Suspected</code>);</li>
<li><em>mediated</em>, when a third server reports a successful response to a <code>forward ping()</code> request that this server had requested, with the <code>Suspected</code> server as the object.</li>
</ul>
<p>When the (configurable) timeout expires, the <code>Suspected</code> server is simply removed from the list and assumed to be <b>terminated</b> (both the <code>Started</code> and <code>terminated</code> states are only "logical", no list is kept, or no special meaning is associated to them).</p>
<p>In particular, we do not gossip about servers that have been determined to be in either state, and we will assume that each of the peers will take care of removing suspected servers from their lists once the timeout (which is not necessarily the same for the entire pool - or even constant over time for a given server) expires.</p>
<p>See the [SWIM Paper](SWIM) for more details.</p>
<p><b>Gossip</b></p>
<p>At regular intervals, a gossiper will pick at random from the list of <code>Alive</code> peers <em>k</em> server, to which it will send a <code>SwimReport</code> containing <b>only</b> the changes since the last report that was sent out (regardless of <em>who</em> it was send out to), as gossipers do not care much for old news.</p>
<p><em>Timing</em> is an issue at present, in that we want to prevent stale news to overwrite newer state information - however, using the report's records' timestamps is unreliable, as different servers will have different system clocks and, potentially, they will be further diverging over time.</p>
<p><code>TODO: this has not been addressed for now</code> </p><hr/>
<h1>References</h1>
<ul>
<li>[SWIM: Scalable Weakly-consistent Infection-style Process Group Membership Protocol](SWIM)</li>
<li>[Unreliable Distributed Failure Detectors for Reliable Systems](detectors)</li>
<li>[A Gossip-Style Failure Detection Service](gossip) </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
